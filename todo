- change the names of the top level variable declaration to indicate that
these are the state variables.

- simplify the declaration section to be a list of pairs where each pair
associates a name to its type (or set expression).

- the transformers that convert a wpca program into a simple form should
be refactored into a separate module because they will be reused by many
language generators.

- change the names of the tests so that it will be clear what they stand for.

- add support for relations

- add support for sets

once we support sets we should be able to write and check an abstract version of the quicksort algorithm (where a set is used to hold the parts that we still need to sort).

- add support for procedures

once we support procedures and arrays we should be able to write and check the partition algorithm. 

- refactor the code into separate programs and use a shell script to bind them together.

  this will greatly simplify the code and the names of each program.

- refactor the code to reflect the architecture

- improve the structure of the alloy module. 
currently we identify the different kinds of variables in an ad-hoc manner.

- find or write a template mechanism for the part that generates the alloy code

- is it beneficial to use cabal instead of make?

- how do we integrate typechecking? as a separate tool? using an attribute grammar?

- create a java module 

- we need to deal with counterexamples that occur because of overflows. when alloy's latest version comes out we can use the 'no overflow' feature. should we do something else in the meantime?
- should we check for a particular alloy version?
- how can we translate alloy's solution to a test case? 
this of course depends on the platform. 

- display the result of analysis in a way that is meaningful to the author of the program.

this problem requires a deeper analysis than I have previously thought. 

we need to display the following information:

- which property was violated (include its location and name: is it a loop invariant or a postcondition?)
- which line of code caused the violation (include its location)
- what is the path that the program follows to get to the offending line of code?
- what are the values that cause the program to follow this path? 

Done

- add support for arrays

this includes:

1. array declaration:

a : array of n int

<name> : array of <size> <type>

<size> : <name>

- the size variable must refer to an integer variable. 
- the precondition is expanded to demand that <size> is not negative.

the relational meaning of an array variable is a sequence. for example:

N : int; A : array of N int

generates the following Alloy state signature:

one sig State {
  N : Int,
  A : seq Int
}

fact {
 all s : State | #s.A = s.N
}

perhaps it is better to define the type nat to stand for natural numbers
including 0. then we can write:

N : nat; A : array of N int

and generate the additional fact

all s : State | s.N >= 0

we can then check that the variable that defines the size of the array is
of type nat.

2. array reference:

- when an array appears in the code it must be inside an array reference.
- when an array appears in a spec it does not have this limitation.
- each reference to the array generates a proof obligation to ensure that the reference is within the array's bounds.

for example, the code:

N : int;
A : array of N int
; x,y := A[i], A[i+j]

generates two proof obligations:

0 <= i and i < N
0 <= i+j and i+j < N

- the relational meaning of an array expression is a relational join. we do not have to change the syntax as the meaning of A[i] in Alloy is precisely what we need.

3. array assignment:

- an array variable can appear at most once in an r-value.

for example, assume that A and B are arrays.  this is ok:

A[i],B[j] := e1,e2

this is illegal:

A[i],A[j] := e1,e2

- the relational meaning of an array assignment is an update:

A[i] := e

becomes

A := A ++ i->e

relax this requirement and instead collect all the assignments to 
the same array in a single update:

A[i],A[j] := e1,e2

becomes

A := A ++ (i->e1 + j->e2)

this makes it possible to swap array elements using the same
code as to swap variables:

A[i],A[j] := A[j], A[i]

Note that because we require that A is a sequence we automatically
exclude cases where (i = j and e1 != e2). To detect these errors
we must add a proof obligation: (i != j or e1 = e2) of course we
must extend this to the general case.


- add support for quantifiers

  - quantifiers can appear only in assertions

  - we must change the substitution algorithm to avoid capturing free variables and to generate unique names that are easy to relate to the original names.

    alternatively we can flag this as an error and ask the progammer to give diffferent names to her local variables.

- change the configuration file syntax to support strings with space 
  this requires start codes but they work only with a monad lexer. 

- add location information to the ast nodes

- change the code to use the new rose-tree like structure of the ast

- create a separate assertion for each code segment. 

we may name the assertions according to the line number in which the code segment begins
we can keep the line number of each statement in the corresponding node.

- activate alloy from wpca

- what is the architecture of wpca? 

see here:

https://docs.google.com/drawings/d/1h_HZwbjf_Jyvit_fmtb6thQtI1TqhqZXDZqjQyWldF0/edit?hl=en_GB


the general architecture is a central repository (the ast) on which various tools operate :
  the lexer and parser build the repository
  and the platform dependant tools generate code from the repository (should we model where they store their output or is that beyond the scope of the system?)
  within each tool the architecture is specific to the tool. for example, the alloy tool
  has a layered architecture :

   first (lowest) layer: functions that calculate free variables, substitutions and so on
   second layer: the weakest precondition calculator
   third (highest) layer: generating the alloy code, invoking the analyzer and reporting the results.

- separate the alloy checks according to the code segments. this way it will be easier to understand which part of the program is incorrect

we can use the theorem 

wp(s,p and q) = wp(s,p) and wp(s,q) 

to separate obligation checks into multiple alloy checks.
- support analysis functions and relations: if a name is not a state variable and it is not a constant (that is, it does not appear in an equality expression with a state variable) then we assume that it is a modeling variable.
- put parenthesis around expressions 
- move project to github
- read from file
- create configuration file to guide translation?
- need to control: scope, sat solver, platform, name of analysis file, should analysis file be kept or deleted, 
- given platform need to control:
-  name of file,procedure,class,method, package and so on

