
- refactor the code to reflect the architecture

- improve the structure of the alloy module. 
currently we identify the different kinds of variables in an ad-hoc manner.

- find or write a template mechanism for the part that generates the alloy code

- is it beneficial to use cabal instead of make?

- how do we integrate typechecking? as a separate tool? using an attribute grammar?

- create a java module 

- we need to deal with counterexamples that occur because of overflows. when alloy's latest version comes out we can use the 'no overflow' feature. should we do something else in the meantime?
- should we check for a particular alloy version?
- how can we translate alloy's solution to a test case? 
this of course depends on the platform. 

- display the result of analysis in a way that is meaningful to the author of the program.

Done

- change the configuration file syntax to support strings with space 
  this requires start codes but they work only with a monad lexer. 

- add location information to the ast nodes

- change the code to use the new rose-tree like structure of the ast

- create a separate assertion for each code segment. 

we may name the assertions according to the line number in which the code segment begins
we can keep the line number of each statement in the corresponding node.

- activate alloy from wpca

- what is the architecture of wpca? 

see here:

https://docs.google.com/drawings/d/1h_HZwbjf_Jyvit_fmtb6thQtI1TqhqZXDZqjQyWldF0/edit?hl=en_GB


the general architecture is a central repository (the ast) on which various tools operate :
  the lexer and parser build the repository
  and the platform dependant tools generate code from the repository (should we model where they store their output or is that beyond the scope of the system?)
  within each tool the architecture is specific to the tool. for example, the alloy tool
  has a layered architecture :

   first (lowest) layer: functions that calculate free variables, substitutions and so on
   second layer: the weakest precondition calculator
   third (highest) layer: generating the alloy code, invoking the analyzer and reporting the results.

- separate the alloy checks according to the code segments. this way it will be easier to understand which part of the program is incorrect

we can use the theorem 

wp(s,p and q) = wp(s,p) and wp(s,q) 

to separate obligation checks into multiple alloy checks.
- support analysis functions and relations: if a name is not a state variable and it is not a constant (that is, it does not appear in an equality expression with a state variable) then we assume that it is a modeling variable.
- put parenthesis around expressions 
- move project to github
- read from file
- create configuration file to guide translation?
- need to control: scope, sat solver, platform, name of analysis file, should analysis file be kept or deleted, 
- given platform need to control:
-  name of file,procedure,class,method, package and so on

